# Объектно-ориентированное программирование и паттерны проектирования (на примере Java)

## Содержание
1. [Введение](#1-введение)
2. [Основные принципы ООП](#2-основные-принципы-ооп)
    - [Инкапсуляция](#21-инкапсуляция)
    - [Наследование](#22-наследование)
    - [Полиморфизм](#23-полиморфизм)
3. [Отношения между классами](#3-отношения-между-классами)
4. [Паттерны проектирования](#4-паттерны-проектирования)
    - [Порождающие](#41-порождающие-шаблоны)
    - [Структурные](#42-структурные-шаблоны)
    - [Поведенческие](#43-поведенческие-шаблоны)
5. [Заключение](#5-заключение)

---

## 1. Введение

*Объектно-ориентированное программирование (ООП)* — это парадигма программирования,
основанная на концепции объектов, которые содержат данные (атрибуты) и методы (функции) для работы с этими данными.
Основные преимущества:
- Модульность
- Повторное использование кода
- Гибкость архитектуры

*Паттерны проектирования* — это проверенные решения типовых проблем в разработке программного обеспечения.
Основные преимущества:
- Ускоряют разработку
- Улучшают читаемость кода
- Облегчают поддержку

---

## 2. Основные принципы ООП

Есть три основных принципа ООП:
1) Инкапсуляция
2) Наследование
3) Полиморфизм

В некоторых источниках выделяют еще один - Абстракция, основная идея которого состоит в том, чтобы представить объект
обладающим набором методов и при этом не предоставлять конкретную логику этих методов.

В Java примером абстракции служат классы со специальным словом `abstract` или `interface`.

### 2.1 Инкапсуляция

*Инкапсуляция* — это механизм сокрытия внутренней реализации объекта и предоставления безопасного интерфейса для взаимодействия.

Пример: [BankAccount.java](src/oop/encapsulation/BankAccount.java)

**Характеристики:**
- Приватные поля (`private`)
- Публичные методы-аксессоры
- Валидация данных

### 2.2 Наследование

Наследование позволяет создавать новые классы на основе существующих, переиспользуя их функциональность.

Пример: [Animal.java](src/oop/inheritance/Animal.java)

**Особенности:**
- Ключевое слово `extends` (`implements` в случае реализации `interface`)
- Аннотация `@Override`
- Одиночное наследование (есть языки с поддержкой множественного наследования, например, Python)

### 2.3 Полиморфизм

Полиморфизм позволяет использовать один интерфейс для работы с разными типами данных.

Делится на несколько видов:
- Статический полиморфизм (Перегрузка методов) -> [Calculator.java](src/oop/polymorphism/Calculator.java)
- Динамический полиморфизм (Переопределение методов) -> [Shape.java](src/oop/polymorphism/Shape.java)
- Параметрический полиморфизм (Дженерики) -> [Box.java](src/oop/polymorphism/Box.java)

---

## 3. Отношения между классами

В контексте ООП нельзя не упомянуть отношения между классами, которые помогут нам понять связи между сущностями при их использовании в паттернах.

Существуют три основных типа отношений между классами:

| Тип отношения  | Описание                                                                | Жизненный цикл                                | Пример                   |
|----------------|-------------------------------------------------------------------------|-----------------------------------------------|--------------------------|
| **Композиция** | Сильная связь "часть-целое", где часть не может существовать без целого | Часть создается и уничтожается вместе с целым | Двигатель и автомобиль   |
| **Агрегация**  | Слабая связь "часть-целое", где часть может существовать независимо     | Часть может существовать до/после целого      | Студент и учебная группа |
| **Ассоциация** | Общее отношение, когда объекты знают друг о друге                       | Объекты существуют независимо                 | Преподаватель и студент  |

### Ключевые различия:

1. **Степень зависимости**:
    - Композиция: максимальная зависимость
    - Агрегация: умеренная зависимость
    - Ассоциация: минимальная зависимость

2. **Использование**:
    - Композиция: когда часть не имеет смысла без целого
    - Агрегация: когда часть может принадлежать разным целым
    - Ассоциация: для любых временных связей

3. **Реализация в коде**:
    - Композиция: создание объекта внутри класса
    - Агрегация: передача объекта через конструктор/метод
    - Ассоциация: ссылки между независимыми объектами

---

## 4. Паттерны проектирования

Паттерны проектирования делят на три группы:
1) *Порождающие шаблоны*
2) *Структурные шаблоны*
3) *Поведенческие шаблоны*

### 4.1 Порождающие шаблоны

Шаблоны проектирования, которые абстрагируют процесс инстанцирования.
Они позволяют сделать систему независимой от способа создания, композиции и представления объектов.

#### 4.1.1 Одиночка

Класс, который может иметь только один экземпляр.

Пример: [Database.java](src/patterns/creational/singleton/Database.java)

#### 4.1.2 Фабричный метод

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.

Пример: [Button.java](src/patterns/creational/factorymethod/Button.java)

#### 4.1.3 Строитель

Класс, который представляет собой интерфейс для создания сложного объекта.

Пример: [Pizza.java](src/patterns/creational/builder/Pizza.java)

### 4.2 Структурные шаблоны

Определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию,
позволяя облегчить разработку и оптимизировать программу.

#### 4.2.1 Адаптер

Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.

Пример: [ModernPrinter.java](src/patterns/structural/adapter/ModernPrinter.java)

#### 4.2.2 Компоновщик

Объект, который объединяет в себе объекты, подобные ему самому.

Пример: [Graphic.java](src/patterns/structural/composite/Graphic.java)

#### 4.2.3 Декоратор

Класс, расширяющий функциональность другого класса без использования наследования.

Пример: [Coffee.java](src/patterns/structural/decorator/Coffee.java)

### 4.3 Поведенческие шаблоны

Определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

#### 4.3.1 Наблюдатель

Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

Пример: [Observer.java](src/patterns/behavioral/observer/Observer.java)

#### 4.3.2 Стратегия

Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.

Пример: [PaymentStrategy.java](src/patterns/behavioral/strategy/PaymentStrategy.java)

#### 4.3.3 Команда

Представляет действие. Объект команды заключает в себе само действие и его параметры.

Пример: [Command.java](src/patterns/behavioral/command/Command.java)

---

## 5. Заключение

Объектно-ориентированное программирование в сочетании с паттернами проектирования образует мощный фундамент для создания качественного программного обеспечения.
Основные принципы ООП предоставляют необходимые механизмы для построения гибких и поддерживаемых систем.

### Ключевые преимущества

- **Структурированность кода** - четкое разделение ответственности между объектами
- **Снижение сложности** - через правильную организацию отношений между классами
- **Гибкость архитектуры** - благодаря полиморфизму и абстрактным интерфейсам
- **Эффективное решение типовых задач** - с помощью проверенных паттернов проектирования

### Практические рекомендации

1. **Применяйте осознанно**:
    - Учитывайте масштаб и сложность проекта
    - Оценивайте требования к производительности
    - Прогнозируйте эволюцию системы

2. **Дальнейшее развитие**:
    - Изучайте SOLID-принципы
    - Анализируйте антипаттерны
    - Исследуйте применение в популярных фреймворках
    - Практикуйтесь на реальных проектах

### Итоговые выводы

Грамотное сочетание принципов ООП и паттернов проектирования позволяет создавать системы, которые:
- Эффективно решают текущие задачи
- Сохраняют гибкость для будущих изменений
- Обеспечивают возможность масштабирования

Эти инструменты остаются незаменимыми в арсенале современного разработчика, обеспечивая баланс между производительностью, поддерживаемостью и скоростью разработки.
